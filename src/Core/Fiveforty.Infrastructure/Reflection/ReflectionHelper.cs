namespace Fiveforty.Infrastructure.Reflection
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Reflection;

    /// <summary>
    /// Class ReflectionHelper.
    /// </summary>
    public static class ReflectionHelper
    {
        /// <summary>
        /// Gets the concrete classes.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <param name="assembly">The assembly.</param>
        /// <returns>Type[].</returns>
        public static Type[] GetConcreteClasses(this Type type, Assembly assembly)
        {
            return GetInterfaceConcreteClassTypes(assembly, type);
        }

        /// <summary>
        /// Gets the concrete classes.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <param name="assemblies">The assemblies.</param>
        /// <returns>Type[].</returns>
        /// <exception cref="System.ArgumentNullException">assemblies</exception>
        /// <exception cref="ArgumentNullException">assemblies</exception>
        public static Type[] GetConcreteClasses(this Type type, IEnumerable<Assembly> assemblies)
        {
            _ = assemblies ?? throw new ArgumentNullException(nameof(assemblies));

            return assemblies.SelectMany(p => GetInterfaceConcreteClassTypes(p, type)).ToArray();
        }

        /// <summary>
        /// Gets the concrete classes.
        /// </summary>
        /// <typeparam name="TInterface">The type of the t interface.</typeparam>
        /// <param name="assembly">The assembly.</param>
        /// <returns>Type[].</returns>
        public static Type[] GetConcreteClasses<TInterface>(this Assembly assembly)
        {
            return GetInterfaceConcreteClassTypes<TInterface>(assembly);
        }

        /// <summary>
        /// Gets the interface concrete class types.
        /// </summary>
        /// <typeparam name="TInterface">The type of the t interface.</typeparam>
        /// <param name="assembly">The assembly.</param>
        /// <returns>System.Type[].</returns>
        public static Type[] GetInterfaceConcreteClassTypes<TInterface>(Assembly assembly)
        {
            return GetInterfaceConcreteClassTypes(assembly, typeof(TInterface));
        }

        /// <summary>
        /// Gets the interface concrete class types.
        /// </summary>
        /// <param name="assembly">The assembly.</param>
        /// <param name="interfaceType">Type of the interface.</param>
        /// <returns>System.Type[].</returns>
        /// <exception cref="System.ArgumentNullException">assembly</exception>
        /// <exception cref="System.ArgumentNullException">interfaceType</exception>
        /// <exception cref="System.ArgumentException">
        /// The type {interfaceType.Name} is not an interface. - interfaceType
        /// </exception>
        /// <exception cref="System.ArgumentNullException">assembly</exception>
        /// <exception cref="ArgumentNullException">interfaceType</exception>
        /// <exception cref="ArgumentNullException">
        /// The type {interfaceType.Name} is not an interface. - interfaceType
        /// </exception>
        /// <exception cref="ArgumentException">assembly</exception>
        public static Type[] GetInterfaceConcreteClassTypes(Assembly assembly, Type interfaceType)
        {
            _ = assembly ?? throw new ArgumentNullException(nameof(assembly));
            _ = interfaceType ?? throw new ArgumentNullException(nameof(interfaceType));

            if (!interfaceType.IsInterface)
            {
                throw new ArgumentException($"The type {interfaceType.Name} is not an interface.", nameof(interfaceType));
            }
            return assembly.GetTypes()
                        .Where(p => p.IsClass && interfaceType.IsAssignableFrom(p))
                        .ToArray();
        }

        /// <summary>
        /// Gets the interface generic arguments.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <param name="genericInterfaceType">Type of the generic interface.</param>
        /// <returns>Type[].</returns>
        /// <exception cref="System.ArgumentNullException">type</exception>
        /// <exception cref="System.ArgumentNullException">genericInterfaceType</exception>
        /// <exception cref="System.ArgumentException">
        /// The type {genericInterfaceType.Name} is not a generic interface. - genericInterfaceType
        /// </exception>
        /// <exception cref="System.ArgumentException">
        /// The type {genericInterfaceType.Name} is not assignable from {type.Name}. - genericInterfaceType
        /// </exception>
        /// <autogeneratedoc/>
        public static Type[] GetInterfaceGenericArguments(this Type type, Type genericInterfaceType)
        {
            _ = type ?? throw new ArgumentNullException(nameof(type));
            _ = genericInterfaceType ?? throw new ArgumentNullException(nameof(genericInterfaceType));
            if (!genericInterfaceType.IsInterface || !genericInterfaceType.IsGenericType)
            {
                throw new ArgumentException($"The type {genericInterfaceType.Name} is not a generic interface.", nameof(genericInterfaceType));
            }
            foreach (Type t in type.GetInterfaces())
            {
                if (t.IsGenericType)
                {
                    if (t.GetGenericTypeDefinition() == genericInterfaceType)
                    {
                        return t.GetGenericArguments();
                    }
                }
            }
            throw new ArgumentException($"The type {genericInterfaceType.Name} is not assignable from {type.Name}.", nameof(genericInterfaceType));
        }
    }
}